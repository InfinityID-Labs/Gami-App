type UserId = principal;
type TransferArgs = 
 record {
   amount: TokenAmount;
   memo: opt text;
   to: UserId;
   token: TokenSymbol;
 };
type Transaction = 
 record {
   amount: TokenAmount;
   blockHeight: nat;
   from: opt UserId;
   id: text;
   timestamp: int;
   to: UserId;
   token: TokenSymbol;
   transactionType: text;
 };
type TokenSymbol = text;
type TokenAmount = float64;
type Token = 
 record {
   createdAt: int;
   creator: UserId;
   decimals: nat8;
   name: text;
   symbol: TokenSymbol;
   totalSupply: TokenAmount;
 };
type Result_2 = 
 variant {
   err: text;
   ok: Token;
 };
type Result_1 = 
 variant {
   err: text;
   ok: vec Transaction;
 };
type Result = 
 variant {
   err: text;
   ok: Transaction;
 };
service : {
  balanceOf: (userId: UserId, token: TokenSymbol) -> (TokenAmount) query;
  createToken: (symbol: TokenSymbol, name: text, totalSupply: TokenAmount,
   decimals: nat8) -> (Result_2);
  distributeQuestReward: (userId: UserId, questId: text, tokenRewards:
   vec record {
         TokenSymbol;
         TokenAmount;
       }) -> (Result_1);
  getAllTokens: () -> (vec Token) query;
  getPortfolioValue: (UserId) -> (float64) query;
  getToken: (symbol: TokenSymbol) -> (opt Token) query;
  getTokenStats: (token: TokenSymbol) ->
   (opt
     record {
       circulatingSupply: TokenAmount;
       totalHolders: nat;
       totalTransactions: nat;
     }) query;
  getTransactionHistory: (userId: opt UserId, limit: opt nat) ->
   (vec Transaction) query;
  getUserBalances: (userId: UserId) ->
   (vec record {
          TokenSymbol;
          TokenAmount;
        }) query;
  greet: (name: text) -> (text) query;
  mint: (to: UserId, token: TokenSymbol, amount: TokenAmount, opt text) ->
   (Result);
  transfer: (args: TransferArgs) -> (Result);
}
